<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZ/A Flexible Software Package Documentation: ADC (r_adc_c)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZ/A Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.2.1</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_d_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ADC (r_adc_c)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga52f7eee41184b0a91cfa9e73b1833122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga52f7eee41184b0a91cfa9e73b1833122">R_ADC_C_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga52f7eee41184b0a91cfa9e73b1833122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0ecdfeeb82907f1d20e68284fe8861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga5f0ecdfeeb82907f1d20e68284fe8861">R_ADC_C_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, void const *const p_channel_cfg)</td></tr>
<tr class="separator:ga5f0ecdfeeb82907f1d20e68284fe8861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b8dbb9de7e428dbdc0bdd56c2331a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga71b8dbb9de7e428dbdc0bdd56c2331a4">R_ADC_C_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga71b8dbb9de7e428dbdc0bdd56c2331a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e9ba160e344dc72ab9e862f7ce70db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga11e9ba160e344dc72ab9e862f7ce70db">R_ADC_C_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga11e9ba160e344dc72ab9e862f7ce70db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5b64c160eb0b849ea5043bde9188cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga2a5b64c160eb0b849ea5043bde9188cb">R_ADC_C_ScanGroupStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a> group_id)</td></tr>
<tr class="separator:ga2a5b64c160eb0b849ea5043bde9188cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ba1ea2171aafa77a4ea3de325ad11c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gad2ba1ea2171aafa77a4ea3de325ad11c">R_ADC_C_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gad2ba1ea2171aafa77a4ea3de325ad11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d98d3b28202140cc37796dd60fde5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1d98d3b28202140cc37796dd60fde5e3">R_ADC_C_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:ga1d98d3b28202140cc37796dd60fde5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0971485949f985d827aeaa69feff4f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga0971485949f985d827aeaa69feff4f5a">R_ADC_C_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:ga0971485949f985d827aeaa69feff4f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95fbc1b2b5d7ced0f332c6cab3be5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gad95fbc1b2b5d7ced0f332c6cab3be5a0">R_ADC_C_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:gad95fbc1b2b5d7ced0f332c6cab3be5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002b131506372adc9b7117ac980dd077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga002b131506372adc9b7117ac980dd077">R_ADC_C_SampleStateCountSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, uint16_t num_states)</td></tr>
<tr class="separator:ga002b131506372adc9b7117ac980dd077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e75a0613a836dda17e8dff336fa5b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga51e75a0613a836dda17e8dff336fa5b9">R_ADC_C_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga51e75a0613a836dda17e8dff336fa5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a6bcd25e5366666a3f25062e4b9d615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1a6bcd25e5366666a3f25062e4b9d615">R_ADC_C_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t offset)</td></tr>
<tr class="separator:ga1a6bcd25e5366666a3f25062e4b9d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cbf5113221d2cdbf11f36eb8b7ea21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga5cbf5113221d2cdbf11f36eb8b7ea21a">R_ADC_C_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void const *p_extend)</td></tr>
<tr class="separator:ga5cbf5113221d2cdbf11f36eb8b7ea21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1644c43f8469049a20a1c183682b2eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1644c43f8469049a20a1c183682b2eda">R_ADC_C_CallbackSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga1644c43f8469049a20a1c183682b2eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the ADC peripheral on RZ/A3UL. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-adc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-adc-features"></a>
Features</h2>
<p>The ADC module supports the following features:</p>
<ul>
<li>12 bit resolution depending on the MPU</li>
<li>Supports selection of multiple analog input channels</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers<a class="anchor" id="um_adc_starting_a_conversion"></a></li>
<li>Hardware scan triggers<ul>
<li>Asynchronous trigger using an external pin (ADC_TRG)</li>
<li>Synchronous trigger using the multi-function timer pulse unit 3 (MTU3a)</li>
<li>In hardware trigger mode, the available trigger input modes are auto mode and step mode</li>
</ul>
</li>
<li>External scan triggers from the ADTRGn port pins</li>
</ul>
</li>
<li>Configurable operating mode:<ul>
<li>Select mode to convert the specified single analog input channel</li>
<li>Scan mode to convert the analog inputs of arbitrarily selected channels in ascending order of channel number</li>
<li>1-buffer mode or 4-buffer mode can be specified for storing the A/D conversion result</li>
</ul>
</li>
<li>Configurable conversion mode:<ul>
<li>Single mode to proceed A/D conversion only once</li>
<li>Repeat mode to repeatedly proceed A/D conversion</li>
</ul>
</li>
<li>Optional callback when scan completes<a class="anchor" id="um_adc_interrupt_callback_data"></a></li>
<li>An A/D conversion end interrupt (INTAD) can be generated on completion of A/D conversion</li>
<li>The division ratio of ADC_ADCLK (TSU clock) can only be set to 4, and other settings are prohibited</li>
<li>Sample and hold support</li>
</ul>
<h1><a class="anchor" id="r-adc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_adc_configure_single_scan_mode"></a><a class="anchor" id="um_adc_configure_software_trigger"></a><a class="anchor" id="um_adc_configure_continuous_mode"></a><a class="anchor" id="um_adc_reading_conversion_data"></a><a class="anchor" id="um_adc_configure_step_mode"></a><a class="anchor" id="um_adc_configure_4buffer_mode"></a><a class="anchor" id="um_adc_configure_scan_mode"></a> <h2>Build Time Configurations for r_adc_c</h2>
The following build time configurations are defined in fsp_cfg/r_adc_c_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Analog &gt; ADC Driver on r_adc_c</h2>
This module can be added to the Stacks tab via New Stack &gt; Analog &gt; ADC Driver on r_adc_c.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_adc0 </td><td>Module name </td></tr>
<tr>
<td>General &gt; Trigger mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Software trgger mode</li>
<li>
Hardware trgger mode</li>
</ul>
</td><td>Software trgger mode </td><td>Select trigger mode. </td></tr>
<tr>
<td>General &gt; Operating mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Scan mode</li>
<li>
Select mode</li>
</ul>
</td><td>Scan mode </td><td>Select the operating mode. </td></tr>
<tr>
<td>General &gt; Conversion mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single mode</li>
<li>
Repeat mode</li>
</ul>
</td><td>Single mode </td><td>Select the conversion mode. </td></tr>
<tr>
<td>General &gt; Buffer mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1-buffer mode</li>
<li>
4-buffer mode</li>
</ul>
</td><td>1-buffer mode </td><td>Select the buffer mode.4-buffer mode is prohibited in scan mode. </td></tr>
<tr>
<td>General &gt; Analog input channel</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Channel 0</li>
<li>
Channel 1</li>
</ul>
</td><td></td><td>Specify the analog input channel.Multiple selection is prohibited in select mode. </td></tr>
<tr>
<td>General &gt; Sampling time</td><td>Value must be between 6 and 2800</td><td>6 </td><td>Set the sampling time.(unit:ADIVCLK cycle) </td></tr>
<tr>
<td>General &gt; Number of stages of the AD external trigger pin filter</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
4 stages</li>
<li>
8 stages</li>
<li>
12 stages</li>
<li>
16 stages</li>
</ul>
</td><td>Disabled </td><td>Select the number of stages of the AD external trigger pin filter.The signal to be filtered is ADC_ADCLK(TSUÏ•) (80 MHz). </td></tr>
<tr>
<td>Hardware trigger mode &gt; Hardware trigger source</td><td>Refer to the RZA Configuration tool for available options.</td><td>External trigger input (ADC_TRG) </td><td>Select hardware trigger source. </td></tr>
<tr>
<td>Hardware trigger mode &gt; Valid edge of the trigger source (Only when ADC_TRG is selected)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Falling edge</li>
<li>
Rising edge</li>
<li>
Both edges</li>
</ul>
</td><td>Falling edge </td><td>Select the valid edge of the trigger. </td></tr>
<tr>
<td>Hardware trigger mode &gt; Trigger input mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Auto mode</li>
<li>
Step mode</li>
</ul>
</td><td>Auto mode </td><td>Selects the trigger input mode. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided here. If this callback function is provided, it is called from the interrupt service routine (ISR) </td></tr>
<tr>
<td>Interrupts &gt; Conversion end interrupt Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Enable or disable the conversion end interrupt. </td></tr>
<tr>
<td>Interrupts &gt; Conversion end Interrupt Priority</td><td>Value must be between 0 and 31</td><td>24 </td><td>Select the interrupt priority for Conversion end. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-adc-clock-configuration"></a>
Clock Configuration</h2>
<p>The ADC clock is ADC_ADCLK(TSU clock)(80 MHz)</p>
<h2><a class="anchor" id="r-adc-pin-configuration"></a>
Pin Configuration</h2>
<p>The ADC_CHx pins are analog input channels that can be used with the ADC.</p>
<p><a class="anchor" id="um_adc_configure_the_external_trigger"></a>ADC_TRG can be used to start scans with an external trigger. When external triggers are used, ADC scans begin on the falling edge of the ADTRG pin.</p>
<h1><a class="anchor" id="r-adc-usage_notes"></a>
Usage Notes</h1>
<h2>Sample Hold</h2>
<p>Enabling the sample and hold functionality reduces the maximum scan frequency because the sample and hold time is added to each scan. Refer to the hardware manual for details on the sample and hold time.</p>
<h2>ADC Conversion Modes</h2>
<p>Single mode and repeat mode are available.</p>
<h3>Single-scan Mode</h3>
<p>In single scan mode, one or more specified channels are scanned once per trigger.</p>
<h3>Repeat-scan Mode</h3>
<p>In repeat scan mode, a single trigger is required to start the scan. Scans continue until <a class="el" href="group___a_d_c.html#gad2ba1ea2171aafa77a4ea3de325ad11c">R_ADC_C_ScanStop()</a> is called.</p>
<h2>ADC Trigger Modes</h2>
<p>Software trigger mode and hardware trigger mode are the two types of trigger modes in which the trigger is the timing for starting the A/D conversion processing.</p>
<h3>Software-trigger Mode</h3>
<p>In software trigger mode, A/D conversion is started for the input of the ADC_CH1, ADC_CH0 pins. The hardware trigger is invalid when software trigger mode is set.</p>
<h3>Hardware-trigger Mode</h3>
<p>There are two triggers in hardware trigger mode: asynchronous trigger using the ADC_TRG pin as the activation source and synchronous trigger using the multi-function timer pulse unit 3 (MTU3a) as the activation source. In hardware trigger mode, the available trigger input modes are auto mode and step mode. In auto mode, when a hardware trigger is input once, A/D conversion is repeated automatically for the conversion count in accordance with the specified conversion settings. In step mode, A/D conversion proceeds every time a hardware trigger is input. For example, if select mode, single mode, and 4- buffer mode are selected, conversion finishes when a hardware trigger has been input four times.</p>
<h2>ADC Operating Modes</h2>
<p>There are two operating modes: select mode and scan mode. The select mode has 1-buffer mode and 4-buffer mode as sub-modes.</p>
<h3>Select Mode</h3>
<p>A/D conversion proceeds for the analog input specified. The A/D conversion results are stored in the ADCR3 to ADCR0 registers corresponding to the analog inputs. In select mode, 1-buffer mode or 4-buffer mode can be used as the method for storing the A/D conversion results. Only one channel is selectable for A/D conversion in select mode.</p>
<p>In 1-buffer mode, A/D conversion proceeds only once for the analog input specified. This mode is usable for reading the result of a single conversion.</p>
<p>In 4-buffer mode, A/D conversion proceeds four times for the analog input specified and the conversion results are stored ADCR3 to ADCR0 registers. This mode is usable for obtaining the average of the A/D conversion results.</p>
<h3>Scan Mode</h3>
<p>A/D conversion proceeds for the analog inputs of channels selected, in ascending order of channel number. The A/D conversion results are stored in the ADCR3 to ADCR0 registers corresponding to the analog inputs. This mode is usable for constantly monitoring multiple analog signals. In scan mode, only 1-buffer mode can be specified.</p>
<h2>When Interrupts Are Not Enabled</h2>
<p>If interrupts are not enabled, the R_ADC_C_StatusGet API can be used to poll the ADC to determine when the scan has completed. The read API function is used to access the converted ADC result.</p>
<h2>Sample-State Count Setting</h2>
<p>The application program can modify the setting of the sample-state count for analog channels by calling the <a class="el" href="group___a_d_c.html#ga002b131506372adc9b7117ac980dd077">R_ADC_C_SampleStateCountSet()</a> API function. To modify the sample-state count, set the number of states when calling the <a class="el" href="group___a_d_c.html#ga002b131506372adc9b7117ac980dd077">R_ADC_C_SampleStateCountSet()</a> API function. Valid sample state counts are 6-2800.</p>
<h1><a class="anchor" id="r-adc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the ADC in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* A channel configuration is generated by the Configuration editor based on the options selected.  If additional</span></div><div class="line"><span class="comment"> * configurations are desired additional adc_c_channel_cfg_t elements can be defined and passed to R_ADC_C_ScanCfg. */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="group___a_d_c.html#structadc__c__channel__cfg__t">adc_c_channel_cfg_t</a> g_adc0_channel_cfg =</div><div class="line">{</div><div class="line">      .<a class="code" href="group___a_d_c.html#a1124a6766edf4954d95d01d6d8e46548">scan_mask</a>                = <a class="code" href="group___a_d_c.html#gga2f01cf47970d9f474abd9f8b68a36abfaa6022698b4c9597d629c54a2b24c35c1">ADC_C_MASK_CHANNEL_1</a> | 0,</div><div class="line">      .interrupt_setting        = <a class="code" href="group___a_d_c.html#ggab74afcc80bd6ce8980feeadb9352449ea06c8e5e55d072c7d8f0825b701dd27ab">ADC_C_INTERRUPT_CHANNEL_SETTING_DISABLE</a>,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga52f7eee41184b0a91cfa9e73b1833122">R_ADC_C_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable channels. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga5f0ecdfeeb82907f1d20e68284fe8861">R_ADC_C_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_C_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_C_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga11e9ba160e344dc72ab9e862f7ce70db">R_ADC_C_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c.html#ga1d98d3b28202140cc37796dd60fde5e3">R_ADC_C_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t channel1_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga0971485949f985d827aeaa69feff4f5a">R_ADC_C_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__c__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__c__extended__cfg__t">adc_c_extended_cfg_t</a></td></tr>
<tr class="separator:structadc__c__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__c__channel__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__c__channel__cfg__t">adc_c_channel_cfg_t</a></td></tr>
<tr class="separator:structadc__c__channel__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__c__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__c__instance__ctrl__t">adc_c_instance_ctrl_t</a></td></tr>
<tr class="separator:structadc__c__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2f01cf47970d9f474abd9f8b68a36abf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga2f01cf47970d9f474abd9f8b68a36abf">adc_c_mask_t</a> </td></tr>
<tr class="separator:ga2f01cf47970d9f474abd9f8b68a36abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b54f9f14640dd93668df6b63fa5208"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga63b54f9f14640dd93668df6b63fa5208">adc_c_trigger_mode_t</a> </td></tr>
<tr class="separator:ga63b54f9f14640dd93668df6b63fa5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7491e0c2eab4266fd44d7f92a3c69324"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga7491e0c2eab4266fd44d7f92a3c69324">adc_c_active_trigger_t</a> </td></tr>
<tr class="separator:ga7491e0c2eab4266fd44d7f92a3c69324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddac3354631a273d32f50f65b271de49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaddac3354631a273d32f50f65b271de49">adc_c_trigger_edge_t</a> </td></tr>
<tr class="separator:gaddac3354631a273d32f50f65b271de49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e12110f82b457bdd59bd0dbc0d0d89"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga50e12110f82b457bdd59bd0dbc0d0d89">adc_c_input_mode_t</a> </td></tr>
<tr class="separator:ga50e12110f82b457bdd59bd0dbc0d0d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6acb79f1626e0bd35e6f90752a015c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1f6acb79f1626e0bd35e6f90752a015c">adc_c_operating_mode_t</a> </td></tr>
<tr class="separator:ga1f6acb79f1626e0bd35e6f90752a015c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa825c3919bb78f2b06cfb42e726f507b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaa825c3919bb78f2b06cfb42e726f507b">adc_c_buffer_mode_t</a> </td></tr>
<tr class="separator:gaa825c3919bb78f2b06cfb42e726f507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034ccf534ec5fed75f8c33ad29c8e3be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga034ccf534ec5fed75f8c33ad29c8e3be">adc_c_filter_stage_setting_t</a> </td></tr>
<tr class="separator:ga034ccf534ec5fed75f8c33ad29c8e3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74afcc80bd6ce8980feeadb9352449e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gab74afcc80bd6ce8980feeadb9352449e">adc_c_interrupt_channel_setting_t</a> </td></tr>
<tr class="separator:gab74afcc80bd6ce8980feeadb9352449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__c__extended__cfg__t" id="structadc__c__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__c__extended__cfg__t">&#9670;&nbsp;</a></span>adc_c_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_c_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration structure for ADC. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8b7c376994f8e824a958c1d1d0f8b302"></a><a class="el" href="group___a_d_c.html#ga63b54f9f14640dd93668df6b63fa5208">adc_c_trigger_mode_t</a></td>
<td class="fieldname">
trigger_mode</td>
<td class="fielddoc">
Trigger mode. </td></tr>
<tr><td class="fieldtype">
<a id="a46131143e44246e03f3a6ca768512a05"></a><a class="el" href="group___a_d_c.html#ga7491e0c2eab4266fd44d7f92a3c69324">adc_c_active_trigger_t</a></td>
<td class="fieldname">
trigger_source</td>
<td class="fielddoc">
Hardware trigger source. </td></tr>
<tr><td class="fieldtype">
<a id="a7eb4fc71a82fcf1ecd7574070c4243e3"></a><a class="el" href="group___a_d_c.html#gaddac3354631a273d32f50f65b271de49">adc_c_trigger_edge_t</a></td>
<td class="fieldname">
trigger_edge</td>
<td class="fielddoc">
Valid edge of the trigger source. </td></tr>
<tr><td class="fieldtype">
<a id="adc8e8849121eeb6991ae00b028a8a4b5"></a><a class="el" href="group___a_d_c.html#ga50e12110f82b457bdd59bd0dbc0d0d89">adc_c_input_mode_t</a></td>
<td class="fieldname">
input_mode</td>
<td class="fielddoc">
Trigger input mode. </td></tr>
<tr><td class="fieldtype">
<a id="a81f2c8156907fdc5b0055cd8443f3f25"></a><a class="el" href="group___a_d_c.html#ga1f6acb79f1626e0bd35e6f90752a015c">adc_c_operating_mode_t</a></td>
<td class="fieldname">
operating_mode</td>
<td class="fielddoc">
Operating mode. </td></tr>
<tr><td class="fieldtype">
<a id="a8ccf8c0714c173bc9e9d536df5df56f9"></a><a class="el" href="group___a_d_c.html#gaa825c3919bb78f2b06cfb42e726f507b">adc_c_buffer_mode_t</a></td>
<td class="fieldname">
buffer_mode</td>
<td class="fielddoc">
Buffer mode. </td></tr>
<tr><td class="fieldtype">
<a id="af94b7b8c31dab35dcb7bf1bfe1670d6d"></a>uint16_t</td>
<td class="fieldname">
sampling_time</td>
<td class="fielddoc">
Sampling period. (6~2800) </td></tr>
<tr><td class="fieldtype">
<a id="a9f46b83d1e4e113f06b392ca92eda623"></a><a class="el" href="group___a_d_c.html#ga034ccf534ec5fed75f8c33ad29c8e3be">adc_c_filter_stage_setting_t</a></td>
<td class="fieldname">
external_trigger_filter</td>
<td class="fielddoc">
AD external trigger pin filter. </td></tr>
</table>

</div>
</div>
<a name="structadc__c__channel__cfg__t" id="structadc__c__channel__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__c__channel__cfg__t">&#9670;&nbsp;</a></span>adc_c_channel_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_c_channel_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC channel(s) configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1124a6766edf4954d95d01d6d8e46548"></a>uint32_t</td>
<td class="fieldname">
scan_mask</td>
<td class="fielddoc">
Channels/bits: bit 0 is ch0; bit 1 is ch1. </td></tr>
<tr><td class="fieldtype">
<a id="ac0f2be271c165544bd8c8502f5d4739c"></a><a class="el" href="group___a_d_c.html#gab74afcc80bd6ce8980feeadb9352449e">adc_c_interrupt_channel_setting_t</a></td>
<td class="fieldname">
interrupt_setting</td>
<td class="fielddoc">
Interrupt setting. </td></tr>
</table>

</div>
</div>
<a name="structadc__c__instance__ctrl__t" id="structadc__c__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__c__instance__ctrl__t">&#9670;&nbsp;</a></span>adc_c_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_c_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2f01cf47970d9f474abd9f8b68a36abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f01cf47970d9f474abd9f8b68a36abf">&#9670;&nbsp;</a></span>adc_c_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga2f01cf47970d9f474abd9f8b68a36abf">adc_c_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For ADC Scan configuration adc_channel_cfg_t::scan_mask. Use bitwise OR to combine these masks for desired channels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2f01cf47970d9f474abd9f8b68a36abfa79ec471da64631d27a588d73ef193efe"></a>ADC_C_MASK_OFF&#160;</td><td class="fielddoc"><p>No channels selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2f01cf47970d9f474abd9f8b68a36abfa526b225d2249c0e6b598d0cb15d23baf"></a>ADC_C_MASK_CHANNEL_0&#160;</td><td class="fielddoc"><p>Channel 0 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2f01cf47970d9f474abd9f8b68a36abfaa6022698b4c9597d629c54a2b24c35c1"></a>ADC_C_MASK_CHANNEL_1&#160;</td><td class="fielddoc"><p>Channel 1 mask. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga63b54f9f14640dd93668df6b63fa5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63b54f9f14640dd93668df6b63fa5208">&#9670;&nbsp;</a></span>adc_c_trigger_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga63b54f9f14640dd93668df6b63fa5208">adc_c_trigger_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC trigger mode select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga63b54f9f14640dd93668df6b63fa5208a96075d0fcdc8e5e9fe36ffed03f611e4"></a>ADC_C_TRIGGER_MODE_SOFTWARE&#160;</td><td class="fielddoc"><p>Software trigger mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga63b54f9f14640dd93668df6b63fa5208a7fa4ed8065306ec04e54e7feda2e1dbc"></a>ADC_C_TRIGGER_MODE_HARDWARE&#160;</td><td class="fielddoc"><p>Hardware trigger mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7491e0c2eab4266fd44d7f92a3c69324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7491e0c2eab4266fd44d7f92a3c69324">&#9670;&nbsp;</a></span>adc_c_active_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga7491e0c2eab4266fd44d7f92a3c69324">adc_c_active_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC hardware trigger source select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324ae5fb7188a5493c2087429cf22d4cd2f4"></a>ADC_C_ACTIVE_TRIGGER_EXTERNAL&#160;</td><td class="fielddoc"><p>External trigger input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a38fcc2885633e438bc40bd92a2b84dca"></a>ADC_C_ACTIVE_TRIGGER_TRGA0N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU0.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324abf1cba1bc639bd489c1434a8811f73d2"></a>ADC_C_ACTIVE_TRIGGER_TRGA1N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU1.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a44ab6a715d5c6b4962ee09cd97b9738c"></a>ADC_C_ACTIVE_TRIGGER_TRGA2N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU2.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324abca8fe161c59c71c347623b294e66974"></a>ADC_C_ACTIVE_TRIGGER_TRGA3N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU3.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a558ad6214f6a2921415737991d2092d1"></a>ADC_C_ACTIVE_TRIGGER_TRGA4N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU4.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a105e8fb8e9ac187017ea47c68e8053fa"></a>ADC_C_ACTIVE_TRIGGER_TRGA6N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU6.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a843cb5544350c5c93a91b9c5f68e1e73"></a>ADC_C_ACTIVE_TRIGGER_TRGA7N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU7.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324af54943db6ac19bc3469392b7dd1bf193"></a>ADC_C_ACTIVE_TRIGGER_TRG0N&#160;</td><td class="fielddoc"><p>Compare match with MTU0.TGRE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a60b1a080cb97f8c36886c8d8313f82b9"></a>ADC_C_ACTIVE_TRIGGER_TRG4AN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324aa329f8ae24c1e72627aec16e56add4a8"></a>ADC_C_ACTIVE_TRIGGER_TRG4BN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORB and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a3e9a5e2d5a289cd86dc466fb491976cf"></a>ADC_C_ACTIVE_TRIGGER_TRG4AN_BN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT, or between MTU4.TADCORB and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a2bdbc28656119e798974fb9c2c6a4e63"></a>ADC_C_ACTIVE_TRIGGER_TRG4ABN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT, and between MTU4.TADCORB and MTU4.TCNT (when interrupt skipping function 2 is in use) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a6a3e1e29efd6b0726b986a61d26fbb9c"></a>ADC_C_ACTIVE_TRIGGER_TRG7AN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORA and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324aa6f5ef5945ac95eb9850812798d478c3"></a>ADC_C_ACTIVE_TRIGGER_TRG7BN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORB and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a3966e7fc0d3839758c715ad9a5581587"></a>ADC_C_ACTIVE_TRIGGER_TRG7AN_BN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORA and MTU7.TCNT, or between MTU7.TADCORB and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7491e0c2eab4266fd44d7f92a3c69324a0187bd6ce59d816a9c14d48a7ed745f7"></a>ADC_C_ACTIVE_TRIGGER_TRG7ABN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORA and MTU7.TCNT, and between MTU7.TADCORB and MTU7.TCNT. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaddac3354631a273d32f50f65b271de49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddac3354631a273d32f50f65b271de49">&#9670;&nbsp;</a></span>adc_c_trigger_edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gaddac3354631a273d32f50f65b271de49">adc_c_trigger_edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>valid edge of the trigger select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaddac3354631a273d32f50f65b271de49a3d564c924b8980dfce73223e9447f870"></a>ADC_C_TRIGGER_EDGE_FALLING&#160;</td><td class="fielddoc"><p>Falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaddac3354631a273d32f50f65b271de49ae5220b5deefd335b667937754602a1c1"></a>ADC_C_TRIGGER_EDGE_RISING&#160;</td><td class="fielddoc"><p>Rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaddac3354631a273d32f50f65b271de49ac22d5d31e0596d826fbff03b476f0166"></a>ADC_C_TRIGGER_EDGE_BOTH&#160;</td><td class="fielddoc"><p>Both edges. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga50e12110f82b457bdd59bd0dbc0d0d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e12110f82b457bdd59bd0dbc0d0d89">&#9670;&nbsp;</a></span>adc_c_input_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga50e12110f82b457bdd59bd0dbc0d0d89">adc_c_input_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC trigger input mode select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga50e12110f82b457bdd59bd0dbc0d0d89a3b4fe16ae64b00c994f7273547ab9048"></a>ADC_C_INPUT_MODE_AUTO&#160;</td><td class="fielddoc"><p>Auto mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga50e12110f82b457bdd59bd0dbc0d0d89adbdd34fbb2bc27ddafe211baae444392"></a>ADC_C_INPUT_MODE_STEP&#160;</td><td class="fielddoc"><p>Step mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1f6acb79f1626e0bd35e6f90752a015c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6acb79f1626e0bd35e6f90752a015c">&#9670;&nbsp;</a></span>adc_c_operating_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga1f6acb79f1626e0bd35e6f90752a015c">adc_c_operating_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC operating mode select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1f6acb79f1626e0bd35e6f90752a015ca63cedcfd78a812f8f284c2c256d60579"></a>ADC_C_OPERATING_MODE_SCAN&#160;</td><td class="fielddoc"><p>Scan mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f6acb79f1626e0bd35e6f90752a015caa84e18043bb7ffa605aeedc5fd6c22f9"></a>ADC_C_OPERATING_MODE_SELECT&#160;</td><td class="fielddoc"><p>Select mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa825c3919bb78f2b06cfb42e726f507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa825c3919bb78f2b06cfb42e726f507b">&#9670;&nbsp;</a></span>adc_c_buffer_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gaa825c3919bb78f2b06cfb42e726f507b">adc_c_buffer_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC buffer mode select </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa825c3919bb78f2b06cfb42e726f507bacd2e2ea3702a77919d90e1620f8ecea9"></a>ADC_C_BUFFER_MODE_1&#160;</td><td class="fielddoc"><p>1-buffer mode </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa825c3919bb78f2b06cfb42e726f507baa23674fef20210a76d33298be9253183"></a>ADC_C_BUFFER_MODE_4&#160;</td><td class="fielddoc"><p>4-buffer mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga034ccf534ec5fed75f8c33ad29c8e3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga034ccf534ec5fed75f8c33ad29c8e3be">&#9670;&nbsp;</a></span>adc_c_filter_stage_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga034ccf534ec5fed75f8c33ad29c8e3be">adc_c_filter_stage_setting_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the number of stages of the AD external trigger pin filter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga034ccf534ec5fed75f8c33ad29c8e3bea0cea22fe02a308fa8dcb8622af5be267"></a>ADC_C_FILTER_STAGE_SETTING_DISABLE&#160;</td><td class="fielddoc"><p>Filter is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga034ccf534ec5fed75f8c33ad29c8e3bea58499b9e7e17eae5511957f130890953"></a>ADC_C_FILTER_STAGE_SETTING_4&#160;</td><td class="fielddoc"><p>12.5 ns (80 MHz) x 4 stages </p>
</td></tr>
<tr><td class="fieldname"><a id="gga034ccf534ec5fed75f8c33ad29c8e3beaff4e1eb7b74d3c422f01aafae1b9117f"></a>ADC_C_FILTER_STAGE_SETTING_8&#160;</td><td class="fielddoc"><p>12.5 ns (80 MHz) x 8 stages </p>
</td></tr>
<tr><td class="fieldname"><a id="gga034ccf534ec5fed75f8c33ad29c8e3beaf0ee05127742344df84853d642f4d0e9"></a>ADC_C_FILTER_STAGE_SETTING_12&#160;</td><td class="fielddoc"><p>12.5 ns (80 MHz) x 12 stages </p>
</td></tr>
<tr><td class="fieldname"><a id="gga034ccf534ec5fed75f8c33ad29c8e3bea45fc2724e94b772f7c82f16c108b876f"></a>ADC_C_FILTER_STAGE_SETTING_16&#160;</td><td class="fielddoc"><p>12.5 ns (80 MHz) x 16 stages </p>
</td></tr>
</table>

</div>
</div>
<a id="gab74afcc80bd6ce8980feeadb9352449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab74afcc80bd6ce8980feeadb9352449e">&#9670;&nbsp;</a></span>adc_c_interrupt_channel_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gab74afcc80bd6ce8980feeadb9352449e">adc_c_interrupt_channel_setting_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable the conversion end interrupt of channel </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab74afcc80bd6ce8980feeadb9352449ea06c8e5e55d072c7d8f0825b701dd27ab"></a>ADC_C_INTERRUPT_CHANNEL_SETTING_DISABLE&#160;</td><td class="fielddoc"><p>Interrupt output is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab74afcc80bd6ce8980feeadb9352449ea85786ffac329aa37580a8c071e1ebf13"></a>ADC_C_INTERRUPT_CHANNEL_SETTING_ENABLE&#160;</td><td class="fielddoc"><p>Interrupt output is enabled. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga52f7eee41184b0a91cfa9e73b1833122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52f7eee41184b0a91cfa9e73b1833122">&#9670;&nbsp;</a></span>R_ADC_C_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the ADC module and applies configurations.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is ready for use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The instance control structure has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A callback is provided, but the interrupt is not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f0ecdfeeb82907f1d20e68284fe8861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0ecdfeeb82907f1d20e68284fe8861">&#9670;&nbsp;</a></span>R_ADC_C_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_channel_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the ADC_C scan parameters. Channel specific settings are set in this function. Pass a pointer to <a class="el" href="group___a_d_c.html#structadc__c__channel__cfg__t">adc_c_channel_cfg_t</a> to p_channel_cfg.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel specific settings applied. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71b8dbb9de7e428dbdc0bdd56c2331a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b8dbb9de7e428dbdc0bdd56c2331a4">&#9670;&nbsp;</a></span>R_ADC_C_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the lowest number configured channel and the total number of bytes to be read in order to read the results of the configured channels. If no channels are configured, then a length of 0 is returned.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11e9ba160e344dc72ab9e862f7ce70db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e9ba160e344dc72ab9e862f7ce70db">&#9670;&nbsp;</a></span>R_ADC_C_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start A/D conversion.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Call R_ADC_C_ScanCfg after R_ADC_C_Open before starting a scan.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started (software trigger) or hardware triggers enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another scan is still in progress (software trigger). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a5b64c160eb0b849ea5043bde9188cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a5b64c160eb0b849ea5043bde9188cb">&#9670;&nbsp;</a></span>R_ADC_C_ScanGroupStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_ScanGroupStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a>&#160;</td>
          <td class="paramname"><em>group_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#aeae126b8a09e1ec34e8e3afb4a3344ff">adc_api_t::scanGroupStart</a> is not supported. Use scanStart instead.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2ba1ea2171aafa77a4ea3de325ad11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ba1ea2171aafa77a4ea3de325ad11c">&#9670;&nbsp;</a></span>R_ADC_C_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop A/D conversion.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped (software trigger) or hardware triggers disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d98d3b28202140cc37796dd60fde5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d98d3b28202140cc37796dd60fde5e3">&#9670;&nbsp;</a></span>R_ADC_C_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current ADC_C status and store it in provided pointer p_status.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module status stored in the provided pointer p_status </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0971485949f985d827aeaa69feff4f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0971485949f985d827aeaa69feff4f5a">&#9670;&nbsp;</a></span>R_ADC_C_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad95fbc1b2b5d7ced0f332c6cab3be5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad95fbc1b2b5d7ced0f332c6cab3be5a0">&#9670;&nbsp;</a></span>R_ADC_C_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor register into a 32-bit result.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga002b131506372adc9b7117ac980dd077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002b131506372adc9b7117ac980dd077">&#9670;&nbsp;</a></span>R_ADC_C_SampleStateCountSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_SampleStateCountSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample state count for individual channels. This only needs to be set for special use cases. Normally, use the default values out of reset.</p>
<dl class="section note"><dt>Note</dt><dd>The sample states for the temperature and voltage sensor are set in R_ADC_C_ScanCfg.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Sample state count updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>A/D conversion ongoing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51e75a0613a836dda17e8dff336fa5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e75a0613a836dda17e8dff336fa5b9">&#9670;&nbsp;</a></span>R_ADC_C_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function ends any scan in progress, disables interrupts, and removes power to the A/D peripheral.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a6bcd25e5366666a3f25062e4b9d615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a6bcd25e5366666a3f25062e4b9d615">&#9670;&nbsp;</a></span>R_ADC_C_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a> is not supported.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cbf5113221d2cdbf11f36eb8b7ea21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cbf5113221d2cdbf11f36eb8b7ea21a">&#9670;&nbsp;</a></span>R_ADC_C_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a1020d90e58d3bf86cee2f46a62e62fc4">adc_api_t::calibrate</a> is not supported.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Calibration not supported on this MCU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1644c43f8469049a20a1c183682b2eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1644c43f8469049a20a1c183682b2eda">&#9670;&nbsp;</a></span>R_ADC_C_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_C_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___a_d_c___a_p_i.html#a8d081aba32f84d62e7d48389b1d10b3e">adc_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.2.1 User's Manual Copyright Â© (2023) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
