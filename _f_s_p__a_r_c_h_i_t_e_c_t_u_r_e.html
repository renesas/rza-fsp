<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZ/A Flexible Software Package Documentation: FSP Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZ/A Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.3.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">FSP Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#renesas-ra-software-package-fsp-architecture">FSP Architecture Overview</a><ul><li class="level2"><a href="#c99-use">C99 Use</a></li>
<li class="level2"><a href="#doxygen">Doxygen</a></li>
<li class="level2"><a href="#weak-symbols">Weak Symbols</a></li>
<li class="level2"><a href="#memory-allocation">Memory Allocation</a></li>
<li class="level2"><a href="#fsp-terms">FSP Terms</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-modules">FSP Modules</a></li>
<li class="level1"><a href="#fsp-stacks">FSP Stacks</a></li>
<li class="level1"><a href="#fsp-interfaces">FSP Interfaces</a><ul><li class="level2"><a href="#fsp-interface-enumerations">FSP Interface Enumerations</a></li>
<li class="level2"><a href="#fsp-interface-callback-functions">FSP Interface Callback Functions</a></li>
<li class="level2"><a href="#fsp-internface-data-structures">FSP Interface Data Structures</a><ul><li class="level3"><a href="#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a></li>
<li class="level3"><a href="#fsp-interface-api-structure">FSP Interface API Structure</a></li>
<li class="level3"><a href="#fsp-instance-structure">FSP Interface Instance Structure</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#fsp-instances">FSP Instances</a><ul><li class="level2"><a href="#control-structure">FSP Instance Control Structure</a></li>
<li class="level2"><a href="#fsp-interface-extensions">FSP Interface Extensions</a><ul><li class="level3"><a href="#fsp-extended-configuration-structure">FSP Extended Configuration Structure</a></li>
</ul>
</li>
<li class="level2"><a href="#fsp-instance-api">FSP Instance API</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-api-standards">FSP API Standards</a><ul><li class="level2"><a href="#fsp-function-names">FSP Function Names</a></li>
<li class="level2"><a href="#use-of-const-in-api-parameters">Use of const in API parameters</a></li>
<li class="level2"><a href="#fsp-version-information">FSP Version Information</a></li>
</ul>
</li>
<li class="level1"><a href="#fsp-build-time-configurations">FSP Build Time Configurations</a></li>
<li class="level1"><a href="#fsp-file-structure">FSP File Structure</a></li>
<li class="level1"><a href="#fsp-architecture-in-practice">FSP Architecture in Practice</a><ul><li class="level2"><a href="#fsp-connecting-layers">FSP Connecting Layers</a></li>
<li class="level2"><a href="#using-fsp-modules-in-an-application">Using FSP Modules in an Application</a><ul><li class="level3"><a href="#create-a-module-instance">Create a Module Instance in the RZ Configuration Editor</a></li>
<li class="level3"><a href="#use-the-instance-api">Use the Instance API in the Application</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="renesas-ra-software-package-fsp-architecture"></a>
FSP Architecture Overview</h1>
<p>This guide describes the Renesas Flexible Software Package (FSP) architecture and how to use the FSP Application Programming Interface (API).</p>
<h2><a class="anchor" id="c99-use"></a>
C99 Use</h2>
<p>The FSP uses the ISO/IEC 9899:1999 (C99) C programming language standard. Specific features introduced in C99 that are used include standard integer types (stdint.h), booleans (stdbool.h), designated initializers, and the ability to intermingle declarations and code.</p>
<h2><a class="anchor" id="doxygen"></a>
Doxygen</h2>
<p>Doxygen is the default documentation tool used by FSP. You can find Doxygen comments throughout the FSP source.</p>
<h2><a class="anchor" id="weak-symbols"></a>
Weak Symbols</h2>
<p>Weak symbols are used occasionally in the FSP. They are used to ensure that a project builds even when the user has not defined an optional function.</p>
<h2><a class="anchor" id="memory-allocation"></a>
Memory Allocation</h2>
<p>Dynamic memory allocation through use of the malloc() and free() functions are not used in FSP modules; all memory required by FSP modules is allocated in the application and passed to the module in a pointer. Exceptions are considered only for ports of 3rd party code that require dynamic memory.</p>
<h2><a class="anchor" id="fsp-terms"></a>
FSP Terms</h2>
<table class="doxtable">
<tr>
<th>Term </th><th>Description </th><th>Reference  </th></tr>
<tr>
<td>BSP </td><td>Short for Board Support Package. In the FSP the BSP provides just enough foundation to allow other FSP modules to work together without issue. </td><td><a class="el" href="group___b_s_p___m_c_u.html">MPU Board Support Package</a> </td></tr>
<tr>
<td>Module </td><td>Modules can be peripheral drivers, purely software, or anything in between. Each module consists of a folder with source code, documentation, and anything else that the customer needs to use the code effectively. Modules are independent units, but they may depend on other modules. Applications can be built by combining multiple modules to provide the user with the features they need. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-modules">FSP Modules</a> </td></tr>
<tr>
<td>Driver </td><td>A driver is a specific kind of module that directly modifies registers on the MPU. </td><td>- </td></tr>
<tr>
<td>Interface </td><td>An interface contains API definitions that can be shared by modules with similar features. Interfaces are definitions only and do not add to code size. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interfaces">FSP Interfaces</a> </td></tr>
<tr>
<td>Stacks </td><td>The FSP architecture is designed such that modules work together to form a stack. A stack consists of a top level module and all its dependencies. </td><td><a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-stacks">FSP Stacks</a> </td></tr>
<tr>
<td>Module Instance </td><td>Single and independent instantiation of a module. An application may require two GPT timers. Each of these timers is a module instance of the r_gpt module. </td><td>- </td></tr>
<tr>
<td>Application </td><td>Code that is owned and maintained by the user. Application code may be based on sample application code provided by Renesas, but it is the responsibility of the user to maintain as necessary. </td><td>- </td></tr>
<tr>
<td>Callback Function </td><td>This term refers to a function that is called when an event occurs. As an example, suppose the user would like to be notified every second based on the RTC. As part of the RTC configuration, a callback function can be supplied that will be jumped to during each RTC interrupt. When a single callback services multiple events, the arguments contain the triggering event. Callback functions for interrupts should be kept short and handled carefully because when they are called the MPU is still inside of an interrupt, delaying any pending interrupts. </td><td>- </td></tr>
</table>
<h1><a class="anchor" id="fsp-modules"></a>
FSP Modules</h1>
<p>Modules are the core building block of FSP. Modules can do many different things, but all modules share the basic concept of providing functionality upwards and requiring functionality from below.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-module.svg">figure-fsp-module.svg</object>
<div class="caption">
Modules</div></div>
<p> The amount of functionality provided by a module is determined based on functional use cases. Common functionality required by multiple modules is often placed into a self-contained submodule so it can be reused. Code size, speed and complexity are also considered when defining a module.</p>
<p>The simplest FSP application consists of one module with the Board Support Package (BSP) and the user application on top.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-application-single-module.svg">figure-fsp-application-single-module.svg</object>
<div class="caption">
Module with application</div></div>
<p> The Board Support Package (BSP) is the foundation for FSP modules, providing functionality to determine the MPU used as well as configuring clocks, interrupts and pins. For the sake of clarity, the BSP will be omitted from further diagrams.</p>
<h1><a class="anchor" id="fsp-stacks"></a>
FSP Stacks</h1>
<p>When modules are layered atop one another, an FSP stack is formed. The stacking process is performed by matching what one module provides with what another module requires.</p>
<h1><a class="anchor" id="fsp-interfaces"></a>
FSP Interfaces</h1>
<p>At the architecture level, interfaces are the way that modules provide common features. This commonality allows modules that adhere to the same interface to be used interchangeably. Interfaces can be thought of as a contract between two modules - the modules agree to work together using the information that was established in the contract.</p>
<p>Interfaces aim to provide support for the common features that most users would expect. This means that some of the advanced features of a peripheral (such as IIC) might not be available in the interface. In most cases these features are still available through interface extensions.</p>
<p>In FSP design, interfaces are defined in header files. All interface header files are located in the folder <code>rza/fsp/inc/api</code> and end with <code>*_api.h</code>. Interface extensions are defined in header files in the folder <code>rza/fsp/inc/instances</code>. The following sections detail what makes up an interface.</p>
<h2><a class="anchor" id="fsp-interface-enumerations"></a>
FSP Interface Enumerations</h2>
<p>Whenever possible, interfaces use typed enumerations for function parameters and structure members.</p>
<p>Enumerations remove uncertainty when deciding what values are available for a parameter. FSP enumeration options follow a strict naming convention where the name of the type is prefixed on the available options. Combining the naming convention with the autocomplete feature available in e2 studio (Ctrl + Space) provides the benefits of rapid coding while maintaining high readability.</p>
<h2><a class="anchor" id="fsp-interface-callback-functions"></a>
FSP Interface Callback Functions</h2>
<p>Callback functions allow modules to asynchronously alert the user application when an event has occurred, such as when a byte has been received over a UART channel or an IRQ pin is toggled. FSP driver modules define and handle the interrupt service routines for RZ MPU peripherals to ensure any required hardware procedures are implemented. The interrupt service routines in FSP modules then call the user-defined callbacks to allow the application to respond.</p>
<p>Callback functions must be defined in the user application. They always return <code>void</code> and take a structure for their one parameter. The structure is defined in the interface for the module and is named <code>&lt;interface&gt;_callback_args_t</code>. The contents of the structure may vary depending on the interface, but two members are common: <code>event</code> and <code>p_context</code>.</p>
<p>The <code>event</code> member is an enumeration defined in the interface used by the application to determine why the callback was called. Using the UART example, the callback could be triggered for many different reasons, including when a byte is received, all bytes have been transmitted, or a framing error has occurred. The <code>event</code> member allows the application to determine which of these three events has occurred and handle it appropriately.</p>
<p>The <code>p_context</code> member is used for providing user-specified data to the callback function. In many cases a callback function is shared between multiple channels or module instances; when the callback occurs, the code handling the callback needs context information so that it can determine which module instance the callback is for. For example, if the callback wanted to make an FSP API call in the callback, then at a minimum the callback will need a reference to the relevant control structure. To make this easy, the user can provide a pointer to the control structure as the <code>p_context</code>. When the callback occurs, the control structure is passed in the <code>p_context</code> element of the callback structure.</p>
<p>When a module is not directly used in the user application (that is, it is not the top layer of the stack), its callback function will be handled by the module above. For example, if a module requires a UART interface module the upper layer module will control and use the UART's callback function. In this case the user would not need to create a callback function for the UART module in their application code.</p>
<h2><a class="anchor" id="fsp-internface-data-structures"></a>
FSP Interface Data Structures</h2>
<p>At a minimum, all FSP interfaces include three data structures: a configuration structure, an API structure, and an instance structure.</p>
<h3><a class="anchor" id="fsp-interface-configuration-structure"></a>
FSP Interface Configuration Structure</h3>
<p>The configuration structure is used for the initial configuration of a module during the <code>&lt;MODULE&gt;_Open()</code> call. The structure consists of members such as channel number, bitrate, and operating mode.</p>
<p>The configuration structure is used purely as an input into the module. It may be stored and referenced by the module, so the configuration structure and anything it references must persist as long as the module is open.</p>
<p>The configuration structure is allocated for each module instance in files generated by the RZ Configuration editor.</p>
<p>When FSP stacks are used, it is also important to understand that configuration structures only have members that apply to the current interface. If multiple layers in the same stack define the same configuration parameters then it becomes difficult to know where to modify the option. For example, the baud rate for a UART is only defined in the UART module instance. Any modules that use the UART interface rely on the baud rate being provided in the UART module instance and do not offer it in their own configuration structures.</p>
<h3><a class="anchor" id="fsp-interface-api-structure"></a>
FSP Interface API Structure</h3>
<p>All interfaces include an API structure which contains function pointers for all the supported interface functions.</p>
<h3><a class="anchor" id="fsp-instance-structure"></a>
FSP Interface Instance Structure</h3>
<p>Every FSP interface also has an instance structure. The instance structure encapsulates everything required to use the module:</p>
<ul>
<li>A pointer to the instance API structure (<a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-instance-api">FSP Instance API</a>)</li>
<li>A pointer to the configuration structure</li>
<li>A pointer to the control structure</li>
</ul>
<p>The instance structure is not required at the application layer. It is used to connect modules to their dependencies (other than the BSP).</p>
<p>Instance structures have a standardized name of <code>&lt;interface&gt;_instance_t</code>.</p>
<p>Note that when an instance structure variable is declared, the API is the only thing that is instance specific, not <em>module instance</em> specific. This is because all module instances of the same module share the same underlying module source code. If SPI is being used on SCI channels 0 and 2 then both module instances use the same API while the configuration and control structures are typically different.</p>
<h1><a class="anchor" id="fsp-instances"></a>
FSP Instances</h1>
<p>While interfaces dictate the features that are provided, instances actually implement those features. Each instance is tied to a specific interface. Instances use the enumerations, data structures, and API prototypes from the interface. This allows an application that uses an interface to swap out the instance when needed.</p>
<p>In FSP design, instances consist of the interface extension and API defined in the instance header file located in the folder <code>rza/fsp/inc/instances</code> and the module source <code>rza/fsp/src/&lt;module&gt;</code>.</p>
<h2><a class="anchor" id="control-structure"></a>
FSP Instance Control Structure</h2>
<p>The control structure is used as a unique identifier for the module instance and contains memory required by the module. Elements in the control structure are owned by the module and <em>must not be modified</em> by the application. The user allocates storage for a control structure, often as a global variable, then sends a pointer to it into the <code>&lt;MODULE&gt;_Open()</code> call for a module. At this point, the module initializes the structure as needed. The user must then send in a pointer to the control structure for all subsequent module calls.</p>
<h2><a class="anchor" id="fsp-interface-extensions"></a>
FSP Interface Extensions</h2>
<p>In some cases, instances require more information than is provided in the interface. This situation can occur in the following cases:</p>
<ul>
<li>An instance offers extra features that are not common to most instances of the interface.</li>
<li>An interface must be very generic out of necessity. As an interface becomes more generic, the number of possible instances increases. An example of an interface that must be generic is a block media interface that abstracts functions required by a file system. Possible instances include SD card, SPI Flash, SDRAM, USB, and many more.</li>
</ul>
<p>The <code>p_extend</code> member provides this extension function.</p>
<p>Use of interface extensions is not always necessary. Some instances do not offer an extension since all functionality is provided in the interface. In these cases the <code>p_extend</code> member can be set to NULL. The documentation for each instance indicates whether an interface extension is available and whether it is mandatory or optional.</p>
<h3><a class="anchor" id="fsp-extended-configuration-structure"></a>
FSP Extended Configuration Structure</h3>
<p>When extended configuration is required it can be supplied through the <code>p_extend</code> parameter of the interface configuration structure.</p>
<p>The extended configuration structure is part of the instance, but it is also still considered to be part of the configuration structure. All usage notes about the configuration structure described in <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-interface-configuration-structure">FSP Interface Configuration Structure</a> apply to the extended configuration structure as well.</p>
<p>The extended configuration structure and all typed structures and enumerations required to define it make up the interface extension.</p>
<h2><a class="anchor" id="fsp-instance-api"></a>
FSP Instance API</h2>
<p>Each instance includes a constant global variable tying the interface API functions to the functions provided by the module. The name of this structure is standardized as <code>g_&lt;interface&gt;_on_&lt;instance&gt;</code>.</p>
<h1><a class="anchor" id="fsp-api-standards"></a>
FSP API Standards</h1>
<h2><a class="anchor" id="fsp-function-names"></a>
FSP Function Names</h2>
<p>FSP functions start with the uppercase module name (<code>&lt;MODULE&gt;</code>). All modules have <code>&lt;MODULE&gt;_Open()</code> and <code>&lt;MODULE&gt;_Close()</code> functions. The <code>&lt;MODULE&gt;_Open()</code> function must be called before any of the other functions.</p>
<p>Other functions that will commonly be found are <code>&lt;MODULE&gt;_Read()</code>, <code>&lt;MODULE&gt;_Write()</code>, <code>&lt;MODULE&gt;_InfoGet()</code>, and <code>&lt;MODULE&gt;_StatusGet()</code>. The <code>&lt;MODULE&gt;_StatusGet()</code> function provides a status that could change asynchronously, while <code>&lt;MODULE&gt;_InfoGet()</code> provides information that cannot change after open or can only be updated by API calls. Example function names include:</p>
<ul>
<li><a class="el" href="group___r_s_p_i.html#gabf563431c100264a744239953798e1ea">R_RSPI_Read()</a>, <a class="el" href="group___r_s_p_i.html#gae60c894cc73159eb48885dd1ab0864eb">R_RSPI_Write()</a>, <a class="el" href="group___r_s_p_i.html#gad52ea6e5651ab88e2cbacfec46f6a4b3">R_RSPI_WriteRead()</a></li>
<li><a class="el" href="group___g_t_m.html#gaa95357cd0d4d8c43f7a2523d4c3b24f7">R_GTM_StatusGet()</a></li>
<li><a class="el" href="group___l_c_d_c.html#gab5034668fe2f8603e010289ff0199e49">R_LCDC_LayerChange()</a>, <a class="el" href="group___l_c_d_c.html#gaa7f4643d82793424c75a0b1931953799">R_LCDC_BufferChange()</a></li>
<li><a class="el" href="group___c_r_u.html#gab8c802da2f0ee6b92a1c3f428bbfd8e9">R_CRU_CaptureStart()</a>, <a class="el" href="group___c_r_u.html#ga3872588403b232d925a0ba256fd7ade2">R_CRU_CaptureStop()</a></li>
</ul>
<h2><a class="anchor" id="use-of-const-in-api-parameters"></a>
Use of const in API parameters</h2>
<p>The <code>const</code> qualifier is used with API parameters whenever possible.</p>
<p>The <code>const</code> qualifier after the pointer star for both <code>p_ctrl</code> and <code>p_cfg</code> ensures the FSP function does not modify the input pointer addresses. While not fool-proof by any means this does provide some extra checking inside the FSP code to ensure that arguments that should not be altered are treated as such.</p>
<h2><a class="anchor" id="fsp-version-information"></a>
FSP Version Information</h2>
<p>The BSP provides a function <code><a class="el" href="group___b_s_p___m_c_u.html#gaf3ee66233fc75acfcc21a97d7a767aa1">R_FSP_VersionGet()</a></code> which fills in a structure of type <code><a class="el" href="group___r_e_n_e_s_a_s___c_o_m_m_o_n.html#unionfsp__pack__version__t">fsp_pack_version_t</a></code>. This can be used to determine the FSP version at runtime.</p>
<p>There are also <code>FSP_VERSION_*</code> macros in fsp_version.h that can be used to determine the FSP version at build time.</p>
<h1><a class="anchor" id="fsp-build-time-configurations"></a>
FSP Build Time Configurations</h1>
<p>All modules have a build-time configuration header file. Most configuration options are supplied at run time, though options that are rarely used or apply to all instances of a module may be moved to build time. The advantage of using a build-time configuration option is to potentially reduce code size reduction by removing an unused feature.</p>
<p>All modules have a build time option to enable or disable parameter checking for the module. FSP modules check function arguments for validity when possible, though this feature is disabled by default to reduce code size. Enabling it can help catch parameter errors during development and debugging. By default, each module's parameter checking configuration inherits the BSP parameter checking setting (set on the BSP tab of the RZ Configuration editor). Leaving each module's parameter checking configuration set to Default (BSP) allows parameter checking to be enabled or disabled globally in all FSP code through the parameter checking setting on the BSP tab.</p>
<p>If an error condition can reasonably be avoided it is only checked in a section of code that can be disabled by disabling parameter checking. Most FSP APIs can only return FSP_SUCCESS if parameter checking is disabled. An example of an error that cannot be reasonably avoided is the "bus busy" error that occurs when another master is using an I2C bus. This type of error can be returned even if parameter checking is disabled.</p>
<h1><a class="anchor" id="fsp-file-structure"></a>
FSP File Structure</h1>
<p>The high-level file structure of an FSP project is shown below.</p>
<div class="fragment"><div class="line">rza_gen</div><div class="line"></div><div class="line">rza</div><div class="line"></div><div class="line">+---fsp</div><div class="line"></div><div class="line">    +---inc</div><div class="line"></div><div class="line">    |   +---api</div><div class="line"></div><div class="line">    |   \---instances</div><div class="line"></div><div class="line">    \---src</div><div class="line"></div><div class="line">        +---bsp</div><div class="line"></div><div class="line">        \---r_module</div><div class="line"></div><div class="line">rza_cfg</div><div class="line"></div><div class="line">+---fsp_cfg</div><div class="line"></div><div class="line">    +---bsp</div><div class="line"></div><div class="line">    +---driver</div></div><!-- fragment --><p>Directly underneath the base <code>rza</code> folder the folders are split into the source and include folders. Include folders are kept separate from the source for easy browsing and easy setup of include paths.</p>
<p>The <code>rza_gen</code> folder contains code generated by the RZ Configuration editor. This includes global variables for the control structure and configuration structure for each module.</p>
<p>The <code>rza_cfg</code> folder is where configuration header files are stored for each module. See <a class="el" href="_f_s_p__a_r_c_h_i_t_e_c_t_u_r_e.html#fsp-build-time-configurations">FSP Build Time Configurations</a> for information on what is provided in these header files.</p>
<h1><a class="anchor" id="fsp-architecture-in-practice"></a>
FSP Architecture in Practice</h1>
<h2><a class="anchor" id="fsp-connecting-layers"></a>
FSP Connecting Layers</h2>
<p>FSP modules are meant to be both reusable and stackable. It is important to remember that modules are not dependent upon other modules, but upon other interfaces. The user is then free to fulfill the interface using the instance that best fits their needs.</p>
<div class="image">
<object type="image/svg+xml" data="figure-fsp-interface-dependency-connection.svg">figure-fsp-interface-dependency-connection.svg</object>
<div class="caption">
Connecting layers</div></div>
<p> In the image above interface Y is a dependency of interface X and has its own dependency on interface Z. Interface X only has a dependency on interface Y. Interface X has no knowledge of interface Z. This is a requirement for ensuring that layers can easily be swapped out.</p>
<h2><a class="anchor" id="using-fsp-modules-in-an-application"></a>
Using FSP Modules in an Application</h2>
<p>The typical use of an FSP module involves generating required module data then using the API in the application.</p>
<h3><a class="anchor" id="create-a-module-instance"></a>
Create a Module Instance in the RZ Configuration Editor</h3>
<p>The RZ Configuration editor provides a graphical user interface for setting the parameters of the interface and instance configuration structures. It also automatically includes those structures (once they are configured in the GUI) in application-specific header files that can be included in application code.</p>
<p>The RZ Configuration editor allocates storage for the control structures, all required configuration structures, and the instance structure in generated files in the <code>rza_gen</code> folder. Use the <b>Properties</b> window to set the values for the members of the configuration structures as needed. Refer to the Configuration section of the module usage notes for documentation about the configuration options.</p>
<p>If the interface has a callback function option then the application must declare and define the function. The return value is always of type <code>void</code> and the parameter to the function is a typed structure of name <code>&lt;interface&gt;_callback_args_t</code>. Once the function has been defined, assign its name to the <code>p_callback</code> member of the configuration structure. Callback function names can be assigned through the <b>Properties</b> window for the selected module.</p>
<h3><a class="anchor" id="use-the-instance-api"></a>
Use the Instance API in the Application</h3>
<p>Call the module's <code>&lt;MODULE&gt;_Open()</code> function. Pass pointers to the generated control structure and configuration structure. The names of these structures are based on the 'Name' field provided in the configuration editor. The control structure is <code>&lt;Name&gt;_ctrl</code> and the configuration structure is <code>&lt;Name&gt;_cfg</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Each layer in the FSP Stack is responsible for calling the API functions of its dependencies. This means that users are only responsible for calling the API functions at the layer at which they are interfacing. For example, when using RSPI module with a DMAC dependency, the application uses only RSPI APIs. The application starts by calling <a class="el" href="group___r_s_p_i.html#gaa303bc3394f99cd07e2ae96139651529">R_RSPI_Open()</a>. Internally, the RSPI module opens the DMAC. It locates <a class="el" href="group___d_m_a_c.html#ga448a013ad5b91097e45833313d5df354">R_DMAC_Open()</a> by accessing the dependent transfer interface function pointers from the pointers DMAC instances (<a class="el" href="group___s_p_i___a_p_i.html#a312e4358f12551a3f7aaa5f0a09c0501" title="To use SPI DTC/DMAC write transfer, link a transfer instance here. Set to NULL if unused...">spi_cfg_t::p_transfer_tx</a> and <a class="el" href="group___s_p_i___a_p_i.html#ab38fb6af687bdf7e0ea9143499849bc6" title="To use SPI DTC/DMAC read transfer, link a transfer instance here. Set to NULL if unused. ">spi_cfg_t::p_transfer_rx</a>) to open the DMAC.</dd></dl>
<p>Refer to the module usage notes for example code to help get started with any particular module. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.3.0 User's Manual Copyright Â© (2024) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
