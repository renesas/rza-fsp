<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZ/A Flexible Software Package Documentation: Quad Serial Peripheral Interface Flash (r_spibsc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZ/A Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.2.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___s_p_i_b_s_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Quad Serial Peripheral Interface Flash (r_spibsc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6d1d2b0dbbc81e342e67e8e4672522bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga6d1d2b0dbbc81e342e67e8e4672522bd">R_SPIBSC_Open</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const p_cfg) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga6d1d2b0dbbc81e342e67e8e4672522bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7eafa9bef7950f16a37accbf6435d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#gaba7eafa9bef7950f16a37accbf6435d0">R_SPIBSC_Close</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:gaba7eafa9bef7950f16a37accbf6435d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5409bfead7139998373b00a9e7ee17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#gaa5409bfead7139998373b00a9e7ee17f">R_SPIBSC_DirectWrite</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, uint8_t const *const p_src, uint32_t const bytes, bool const read_after_write) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:gaa5409bfead7139998373b00a9e7ee17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77245dfca1f1d3e0b8f84d125b34fce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga77245dfca1f1d3e0b8f84d125b34fce0">R_SPIBSC_DirectRead</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, uint8_t *const p_dest, uint32_t const bytes) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga77245dfca1f1d3e0b8f84d125b34fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af815043c15dc43d8964179a5d0cc1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga9af815043c15dc43d8964179a5d0cc1a">R_SPIBSC_SpiProtocolSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a> spi_protocol) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga9af815043c15dc43d8964179a5d0cc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75bb83a911e944d297109a1293fb8c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga75bb83a911e944d297109a1293fb8c18">R_SPIBSC_XipEnter</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga75bb83a911e944d297109a1293fb8c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08dd33276f59e3978393acf89e2ff889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga08dd33276f59e3978393acf89e2ff889">R_SPIBSC_XipExit</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga08dd33276f59e3978393acf89e2ff889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc110157d679b89cb4c4f752cb4efb41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#gadc110157d679b89cb4c4f752cb4efb41">R_SPIBSC_Write</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, uint8_t const *const p_src, uint8_t *const p_dest, uint32_t byte_count) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:gadc110157d679b89cb4c4f752cb4efb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0912fbc1a4e3df240fcaba680d9d71f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#gaf0912fbc1a4e3df240fcaba680d9d71f">R_SPIBSC_Erase</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, uint8_t *const p_device_address, uint32_t byte_count) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:gaf0912fbc1a4e3df240fcaba680d9d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1eba14ce00a4c9f7bdc9d5ca473c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga7e1eba14ce00a4c9f7bdc9d5ca473c5a">R_SPIBSC_StatusGet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const p_status) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga7e1eba14ce00a4c9f7bdc9d5ca473c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19f99e12b8fdb78e2f2895b6f3a9a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#gac19f99e12b8fdb78e2f2895b6f3a9a80">R_SPIBSC_BankSet</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, uint32_t bank) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:gac19f99e12b8fdb78e2f2895b6f3a9a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95407b1410c47feb1254068abcee82b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const p_transfer, <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a> direction) BSP_PLACE_IN_SECTION(SPIBSC_CFG_CODE_SECTION)</td></tr>
<tr class="separator:ga95407b1410c47feb1254068abcee82b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f156e54ed8c5bb8f2f2094570fa18cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#ga8f156e54ed8c5bb8f2f2094570fa18cc">R_SPIBSC_AutoCalibrate</a> (<a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *p_api_ctrl)</td></tr>
<tr class="separator:ga8f156e54ed8c5bb8f2f2094570fa18cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SPIBSC peripheral on RZ MPUs. This module implements the <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html">SPI Flash Interface</a>. </p>
<h1><a class="anchor" id="r-spibsc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-spibsc-features"></a>
Features</h2>
<p>The SPIBSC driver has the following key features:</p><ul>
<li>Initialization of memory mapped read access to QSPI flash device (Disabled by default. The Initial Program Loader already enables it before running application)</li>
<li>Programming QSPI flash device</li>
<li>Erasing QSPI flash device</li>
<li>Sending device specific commands and reading back responses</li>
<li>Entering and exiting XIP mode</li>
<li>3 or 4 byte addressing</li>
<li>Obtaining write status by de-facto standard instructions</li>
</ul>
<h1><a class="anchor" id="r-spibsc-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_spibsc</h2>
The following build time configurations are defined in driver/r_spibsc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>SPIBSC initialization</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Whether or not to enable initialization of SPIBSC or not. </td></tr>
</table>
 <h2>Configurations for Storage &gt; SPIBSC (r_spibsc)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; SPIBSC (r_spibsc).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_spi_flash0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; SPI Protocol</td><td>Extended SPI</td><td>Extended SPI </td><td>Select the initial SPI protocol. </td></tr>
<tr>
<td>General &gt; Address Bytes</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
3</li>
<li>
4</li>
<li>
4 with 4-byte read code</li>
</ul>
</td><td>3 </td><td>Select the number of address bytes. Selecting '4 with 4-byte read code' converts the default read code determined in Read Mode to the 4-byte version. If 4-byte mode is selected without using 4-byte commands, the application must issue the EN4B command using R_SPIBSC_Direct(). </td></tr>
<tr>
<td>General &gt; Read Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard Read</li>
<li>
Fast Read</li>
<li>
Fast Read Quad Output</li>
<li>
Fast Read Quad I/O</li>
</ul>
</td><td>Fast Read Quad I/O </td><td>Select the read mode for memory mapped access. </td></tr>
<tr>
<td>General &gt; Dummy Clocks for Fast Read</td><td>Refer to the RZA Configuration tool for available options.</td><td>Default </td><td>Select the number of dummy clocks for fast read operations. Default is 6 clocks for Fast Read Quad I/O, and 8 clocks for other fast read instructions including Fast Read Quad Output, and Fast Read </td></tr>
<tr>
<td>General &gt; Page Size Bytes</td><td>Must be an integer greater than 0</td><td>256 </td><td>The maximum number of bytes allowed for a single write. </td></tr>
<tr>
<td>Command Definitions &gt; Read Command</td><td>Must be an 8-bit Read Command under Command Definitions</td><td>0x00 </td><td>The Read command. Set Read Command to 0 if selected by Read Mode and Address Bytes. </td></tr>
<tr>
<td>Command Definitions &gt; Page Program Command</td><td>Must be an 8-bit Page Program Command under Command Definitions</td><td>0x33 </td><td>The command to program a page. </td></tr>
<tr>
<td>Command Definitions &gt; Page Program Address Lines</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
4</li>
</ul>
</td><td>4 </td><td>Select the number of lines to use for the address bytes during write operations. This can be determined by referencing the datasheet for the flash memory device. </td></tr>
<tr>
<td>Command Definitions &gt; Write Enable Command</td><td>Must be an 8-bit Write Enable Command under Command Definitions</td><td>0x06 </td><td>The command to enable write. </td></tr>
<tr>
<td>Command Definitions &gt; Read Status Command</td><td>Must be an 8-bit Read Status Command under Command Definitions</td><td>0x05 </td><td>The command to query the status of a write or erase command. </td></tr>
<tr>
<td>Command Definitions &gt; Write Status Bit</td><td>Must be an integer between 0 and 7</td><td>0 </td><td>Which bit contains the write in progress status returned from the Read Status Command. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Command #1</td><td>Must be an 8-bit Erase Command under Command Definitions</td><td>0x20 </td><td>The command to erase #1. Set Erase Size #1 to 0 if unused. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Size #1</td><td>Must be an integer greater than or equal to 0</td><td>4096 </td><td>The erase size #1. Set Erase Size #1 to 0 if Erase #1 is not supported. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Command #2</td><td>Must be an 8-bit Erase Command under Command Definitions</td><td>0x52 </td><td>The command to erase #2. Set Erase Size #2 to 0 if unused. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Size #2</td><td>Must be an integer greater than or equal to 0</td><td>32768 </td><td>The erase size #2. Set Erase Size #2 to 0 if Erase #2 is not supported. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Command #3</td><td>Must be an 8-bit Erase Command under Command Definitions</td><td>0xD8 </td><td>The command to erase #3. Set Erase Size #3 to 0 if unused. </td></tr>
<tr>
<td>Command Definitions &gt; Erase Size #3</td><td>Must be an integer greater than or equal to 0</td><td>65536 </td><td>The erase size #3. Set Erase Size #3 to 0 if Erase #3 is not supported. </td></tr>
<tr>
<td>Command Definitions &gt; Chip Erase Command</td><td>Must be an 8-bit Chip Erase Command under Command Definitions</td><td>0xC7 </td><td>The command to erase the entire chip. Set Chip Erase Command to 0 if unused. </td></tr>
<tr>
<td>Command Definitions &gt; XIP Enter M7-M0</td><td>Must be an 8-bit XIP Enter M7-M0 command under Command Definitions</td><td>0xa5 </td><td>How to set M7-M0 to enter XIP mode. </td></tr>
<tr>
<td>Command Definitions &gt; XIP Exit M7-M0</td><td>Must be an 8-bit XIP Exit M7-M0 command under Command Definitions</td><td>0x00 </td><td>How to set M7-M0 exit XIP mode. </td></tr>
<tr>
<td>Bus Parameter &gt; IO2 Fix Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable or not the IO2 level will fix during idle state. </td></tr>
<tr>
<td>Bus Parameter &gt; IO2 Fix Value</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 (High)</li>
<li>
0 (Low)</li>
</ul>
</td><td>1 (High) </td><td>Value for IO2 level fix state. </td></tr>
<tr>
<td>Bus Parameter &gt; IO3 Fix Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Enable </td><td>Enable or not the IO3 level will fix during idle state. </td></tr>
<tr>
<td>Bus Parameter &gt; IO3 Fix Value</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 (High)</li>
<li>
0 (Low)</li>
</ul>
</td><td>1 (High) </td><td>Value for IO3 level fix state. </td></tr>
<tr>
<td>Bus Timing &gt; Select to Clock Delay Cycles</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1.5 cycle</li>
<li>
2.5 cycle</li>
<li>
3.5 cycle</li>
<li>
4.5 cycle</li>
<li>
5.5 cycle</li>
<li>
6.5 cycle</li>
<li>
7.5 cycle</li>
<li>
8.5 cycle</li>
</ul>
</td><td>1.5 cycle </td><td>Define the cycles that begin the SCLK from SSL start. </td></tr>
<tr>
<td>Bus Timing &gt; Clock Low to De-select Delay Cycles</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 cycle</li>
<li>
2 cycle</li>
<li>
3 cycle</li>
<li>
4 cycle</li>
<li>
5 cycle</li>
<li>
6 cycle</li>
<li>
7 cycle</li>
<li>
8 cycle</li>
</ul>
</td><td>1 cycle </td><td>Define the cycles that stop the SSL from last SCLK is out. </td></tr>
<tr>
<td>Bus Timing &gt; De-select to Select Delay Cycles</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 cycle</li>
<li>
2 cycle</li>
<li>
3 cycle</li>
<li>
4 cycle</li>
<li>
5 cycle</li>
<li>
6 cycle</li>
<li>
7 cycle</li>
<li>
8 cycle</li>
</ul>
</td><td>5 cycle </td><td>Define the cycles that starts the new SSL from previous SSL finished. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-spibsc-clock-configuration"></a>
Clock Configuration</h2>
<p>The QSPI clock is derived from SPI1&phi;.</p>
<dl class="section note"><dt>Note</dt><dd>This implementation does not change the SPI1&phi; settings. Do call R_FSP_SystemClockHzSet(FSP_PRIV_CLOCK_SPI1CLK, 2nd, 3rd) separately if needed. <table class="doxtable">
<tr>
<th align="left">Desired SPI frequency </th><th align="right">2nd parameter </th><th align="right">3rd parameter  </th></tr>
<tr>
<td align="left">66.625MHz </td><td align="right">0 </td><td align="right">1 </td></tr>
<tr>
<td align="left">50MHz </td><td align="right">1 </td><td align="right">1 </td></tr>
<tr>
<td align="left">33.3125MHz </td><td align="right">0 </td><td align="right">2 </td></tr>
<tr>
<td align="left">25MHz </td><td align="right">1 </td><td align="right">2 </td></tr>
<tr>
<td align="left">16.65625MHz </td><td align="right">0 </td><td align="right">3 </td></tr>
<tr>
<td align="left">12.5MHz </td><td align="right">1 </td><td align="right">3 </td></tr>
<tr>
<td align="left">4.1640625MHz </td><td align="right">0 </td><td align="right">4 </td></tr>
<tr>
<td align="left">3.125MHz </td><td align="right">1 </td><td align="right">4 </td></tr>
</table>
</dd></dl>
<h2><a class="anchor" id="r-spibsc-pin-configuration"></a>
Pin Configuration</h2>
<p>RZ MPUs provide these pins as dedicated.</p>
<h1><a class="anchor" id="r-spibsc-usage_notes"></a>
Usage Notes</h1>
<h2>QSPI Memory Mapped Access</h2>
<p>The IPL already enables as memory-mapped access. By the default, <a class="el" href="group___s_p_i_b_s_c.html#ga6d1d2b0dbbc81e342e67e8e4672522bd">R_SPIBSC_Open()</a> does nothing to configure and only prepare to erase/write.</p>
<h2><a class="anchor" id="r-spibsc-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the SPIBSC driver:</p>
<ul>
<li>While write/erase operation is in progress, do not access flash contents via the memory-mapped area.<ul>
<li>To use the erase, write, or the bankSet function, both the caller's and the callee's codes and datas must not store in the affected flash memory.</li>
<li>It also includes indirect access by interrupt handlers, etc.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-spibsc-examples"></a>
Examples</h1>
<h2>Basic Example (R_SPIBSC_Open, R_SPIBSC_Close, R_SPIBSC_Erase, R_SPIBSC_Write, R_SPIBSC_StatusGet)</h2>
<p>This is a basic write example in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SPIBSC_EXAMPLE_ERASE_LENGTH    (4096)</span></div><div class="line"><span class="preprocessor">#define SPIBSC_EXAMPLE_DATA_LENGTH     (256)</span></div><div class="line"><span class="preprocessor">#define EXAMPLE_TARGET_ADDRESS         ((uint8_t *) 0x20fff000)</span></div><div class="line"><span class="preprocessor">#define ERASE_TEST_VALUE               (0xffffffffffffffffULL)</span></div><div class="line"><span class="preprocessor">#define ERASE_TEST_VALUE_U8            (0xffU)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> uint8_t s_src[SPIBSC_EXAMPLE_DATA_LENGTH] = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">/* Place code in the FASTCODE(On-chip RAM) section. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> r_spibsc_example_wait(<span class="keywordtype">void</span>) BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;FASTCODE&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> r_spibsc_example_wait (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> status;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>          err;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/* Obtaining status */</span></div><div class="line">        err = <a class="code" href="group___s_p_i_b_s_c.html#ga7e1eba14ce00a4c9f7bdc9d5ca473c5a">R_SPIBSC_StatusGet</a>(&amp;g_spi_flash0_ctrl, &amp;status);</div><div class="line"></div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <span class="comment">/* Check it and break if not in progress */</span></div><div class="line">        <span class="keywordflow">if</span> (status.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ae20d4bed523ca4e802f5da6fdec4ca43">write_in_progress</a> == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> check_erased(<span class="keywordtype">void</span> * buf, <span class="keywordtype">size_t</span> size) BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;FASTCODE&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> check_erased (<span class="keywordtype">void</span> * buf, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">    uintptr_t       current = (uintptr_t) buf;</div><div class="line">    <span class="keyword">const</span> uint8_t * u8test;</div><div class="line">    <span class="keywordflow">if</span> (current &amp; 7)</div><div class="line">    {</div><div class="line">        u8test = (<span class="keyword">const</span> uint8_t *) current;</div><div class="line">        uintptr_t remain = current &amp; 7;</div><div class="line">        <span class="keywordflow">while</span> (size &amp;&amp; remain)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (*u8test != ERASE_TEST_VALUE_U8)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            size--;</div><div class="line">            remain--;</div><div class="line">            u8test++;</div><div class="line">        }</div><div class="line"></div><div class="line">        current = (uintptr_t) u8test;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> uint64_t * u64test = (<span class="keyword">const</span> uint64_t *) current;</div><div class="line">        <span class="keywordflow">while</span> (size &gt;= 8)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (*u64test != ERASE_TEST_VALUE)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            size -= 8;</div><div class="line">            u64test++;</div><div class="line">        }</div><div class="line"></div><div class="line">        current = (uintptr_t) u64test;</div><div class="line">    }</div><div class="line"></div><div class="line">    u8test = (<span class="keyword">const</span> uint8_t *) current;</div><div class="line">    <span class="keywordflow">while</span> (size)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (*u8test != ERASE_TEST_VALUE_U8)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        size--;</div><div class="line">        u8test++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> r_spibsc_basic_example(<span class="keywordtype">void</span>) BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;FASTCODE&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> r_spibsc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open SPIBSC instance. */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#ga6d1d2b0dbbc81e342e67e8e4672522bd">R_SPIBSC_Open</a>(&amp;g_spi_flash0_ctrl, &amp;g_spi_flash0_cfg);</div><div class="line"></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga577e9b015e1b0794934fa4f2b229e52f">FSP_ERROR_RETURN</a>(err == FSP_SUCCESS, err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Erase 4KB sector from 0xfff000 via erase API. */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#gaf0912fbc1a4e3df240fcaba680d9d71f">R_SPIBSC_Erase</a>(&amp;g_spi_flash0_ctrl, EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_ERASE_LENGTH);</div><div class="line"></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga577e9b015e1b0794934fa4f2b229e52f">FSP_ERROR_RETURN</a>(err == FSP_SUCCESS, err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for erase complete */</span></div><div class="line">    r_spibsc_example_wait();</div><div class="line"></div><div class="line">    <span class="comment">/* Invalidating SPIBSC cache before invalidating cache */</span></div><div class="line">    R_SPIBSC-&gt;DRCR_b.RCF = 1;</div><div class="line"></div><div class="line">    <span class="comment">/* After the write/erase is completed, invalidating its cached data is required because the contents are useless. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gad2ded52ed898f2826dc446495dbd73d3">R_BSP_CACHE_InvalidateRange</a>((uint64_t) EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_ERASE_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* Validating erase */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga577e9b015e1b0794934fa4f2b229e52f">FSP_ERROR_RETURN</a>(check_erased(EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_ERASE_LENGTH), <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#ggadfb1288da0fcc7ae1dc88c58601374f8aedf5bd340743b4cad2a5b5370bdf3184">FSP_ERR_ERASE_FAILED</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write 256-byte page from 0xfff000 via write API. */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#gadc110157d679b89cb4c4f752cb4efb41">R_SPIBSC_Write</a>(&amp;g_spi_flash0_ctrl, &amp;s_src[0], EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga577e9b015e1b0794934fa4f2b229e52f">FSP_ERROR_RETURN</a>(err == FSP_SUCCESS, err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for erase complete */</span></div><div class="line">    r_spibsc_example_wait();</div><div class="line"></div><div class="line">    <span class="comment">/* Invalidating SPIBSC cache before invalidating cache */</span></div><div class="line">    R_SPIBSC-&gt;DRCR_b.RCF = 1;</div><div class="line"></div><div class="line">    <span class="comment">/* After the write/erase is completed, invalidating its cached data is required because the contents are useless. */</span></div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#gad2ded52ed898f2826dc446495dbd73d3">R_BSP_CACHE_InvalidateRange</a>((uint64_t) EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_DATA_LENGTH);</div><div class="line"></div><div class="line">    <span class="comment">/* Verifying wrote data */</span></div><div class="line">    <span class="keywordflow">if</span> (memcmp(s_src, EXAMPLE_TARGET_ADDRESS, SPIBSC_EXAMPLE_DATA_LENGTH) == 0)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Verify succeed */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Verify failed */</span></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Close SPIBSC instance. */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#gaba7eafa9bef7950f16a37accbf6435d0">R_SPIBSC_Close</a>(&amp;g_spi_flash0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> err;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Reading Flag Status Register Example (R_SPIBSC_DirectTransfer)</h2>
<p>Some flash memories may be polled alternated ways for the "write in progress" status. In this case, developers implement their StatusGet function. There is an example of implementing the StatusGet function using R_SPIBSC_DirectTransfer API.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SPIBSC_COMMAND_READ_FLAG_STATUS_REGISTER    (0x70U)</span></div><div class="line"></div><div class="line"><a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> r_spibsc_own_statusget_example (<span class="keywordtype">bool</span> * p_write_in_progress)</div><div class="line">{</div><div class="line">    <span class="comment">/* Read a flag status register. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> transfer =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a>        = 0,</div><div class="line">        .data           = 0,</div><div class="line">        .command        = SPIBSC_COMMAND_READ_FLAG_STATUS_REGISTER,</div><div class="line">        .dummy_cycles   = 0,</div><div class="line">        .command_length = 1,</div><div class="line">        .address_length = 0,</div><div class="line">        .data_length    = 1</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line"></div><div class="line">    <span class="comment">/* Execute direct transaction */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Status register contents are available in lower-byte of &#39;transfer.data&#39;. */</span></div><div class="line">    <span class="comment">/* Check b7 of returned data */</span></div><div class="line">    <span class="keywordflow">if</span> (transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a> &amp; (1U &lt;&lt; 7))</div><div class="line">    {</div><div class="line">        *p_write_in_progress = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        *p_write_in_progress = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> err;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Querying Device Size Example (R_SPIBSC_DirectTransfer)</h2>
<p>This is an example of using R_SPIBSC_DirectTransfer to query the device size.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define SPIBSC_EXAMPLE_COMMAND_READ_ID      (0x9F)</span></div><div class="line"><span class="preprocessor">#define SPIBSC_EXAMPLE_COMMAND_READ_SFDP    (0x5A)</span></div><div class="line"><span class="preprocessor">#define MAKEUINT32(p1, p2, p3,                                                                                         \</span></div><div class="line"><span class="preprocessor">                   p4)    ((uint32_t) ((uint32_t) (p1) * 0x1000000UL + (uint32_t) (p2) * 0x10000UL + (uint32_t) (p3) * \</span></div><div class="line"><span class="preprocessor">                                       0x100UL +                                                                       \</span></div><div class="line"><span class="preprocessor">                                       (uint32_t) (p4)))</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_spibsc_size_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Many QSPI devices support more than one way to query the device size. Consult the datasheet for your</span></div><div class="line"><span class="comment">     * flash device to determine which of these methods are supported (if any). */</span></div><div class="line">    uint32_t  device_size_bytes;</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err;</div><div class="line">    uint8_t   buffer[16];</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SPIBSC_EXAMPLE_COMMAND_READ_ID</span></div><div class="line"></div><div class="line">    <span class="comment">/* This example shows how to get the device size by reading the manufacturer ID. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> transfer =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a>        = 0,</div><div class="line">        .data           = 0,</div><div class="line">        .command        = SPIBSC_EXAMPLE_COMMAND_READ_ID,</div><div class="line">        .dummy_cycles   = 0,</div><div class="line">        .command_length = 1,</div><div class="line">        .address_length = 0,</div><div class="line">        .data_length    = 3</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Execute direct transaction */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;transfer, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* The third byte often represents the size of the flash device, where the size of the QSPI = 2 ^ N. */</span></div><div class="line">    memcpy(&amp;buffer[0], &amp;transfer.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 3);</div><div class="line">    device_size_bytes = 1U &lt;&lt; buffer[2];</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(device_size_bytes);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SPIBSC_EXAMPLE_COMMAND_READ_SFDP</span></div><div class="line"></div><div class="line">    <span class="comment">/* Read the JEDEC SFDP header to locate the JEDEC flash parameters table. Reference JESD216 &quot;Serial Flash</span></div><div class="line"><span class="comment">     * Discoverable Parameters (SFDP)&quot;. */</span></div><div class="line">    <a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> read_sfdp =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a>        = 0,</div><div class="line">        .data           = 0,</div><div class="line">        .command        = SPIBSC_EXAMPLE_COMMAND_READ_SFDP,</div><div class="line">        .dummy_cycles   = 8,</div><div class="line">        .command_length = 1,</div><div class="line">        .address_length = 3,</div><div class="line">        .data_length    = 4</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Send the standard 0x5A command (SFDP header is at address 0). */</span></div><div class="line">    <span class="comment">/* Read out 16-byte (call R_SPIBSC_DirectTransfer 4-times). */</span></div><div class="line">    err = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[0], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line">    read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a> = 4;</div><div class="line">    err               = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[4], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line">    read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a> = 8;</div><div class="line">    err               = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[8], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line">    read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a> = 12;</div><div class="line">    err               = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[12], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line"></div><div class="line">    <span class="comment">/* Send the standard 0x5A command (address located at offset 0xC-0xE). */</span></div><div class="line">    <span class="comment">/* Read out 8-byte (call R_SPIBSC_DirectTransfer 2-times). */</span></div><div class="line">    read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a> = MAKEUINT32(0, buffer[0xe], buffer[0xd], buffer[0xc]);</div><div class="line">    err               = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[0], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line">    read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a5120cdb55dcd4ce8da04eb8baa69254d">address</a> += 4;</div><div class="line">    err                = <a class="code" href="group___s_p_i_b_s_c.html#ga95407b1410c47feb1254068abcee82b0">R_SPIBSC_DirectTransfer</a>(&amp;g_spi_flash0_ctrl, &amp;read_sfdp, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    memcpy(&amp;buffer[4], &amp;read_sfdp.<a class="code" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a52ae9ed9880e98f7a02107c2b31b673b">data</a>, 4);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the memory density (located in big endian order at offset 0x4-0x7). */</span></div><div class="line">    uint32_t memory_density = MAKEUINT32(buffer[7], buffer[6], buffer[5], buffer[4]);</div><div class="line">    <span class="keywordflow">if</span> ((1U &lt;&lt; 31) &amp; memory_density)</div><div class="line">    {</div><div class="line">        <span class="comment">/* For densities 4 gigabits and above, bit-31 is set to 1b.  The field 30:0 defines N where the density is</span></div><div class="line"><span class="comment">         * computed as 2^N bits (N must be &gt;= 32). This code subtracts 3 from N to divide by 8 to get the size in</span></div><div class="line"><span class="comment">         * bytes instead of bits. */</span></div><div class="line">        device_size_bytes = 1U &lt;&lt; ((memory_density &amp; ~(1U &lt;&lt; 31)) - 3U);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* For densities 2 gigabits or less, bit-31 is set to 0b.  The field 30:0 defines the size in bits. This</span></div><div class="line"><span class="comment">         * code divides the memory density by 8 to get the size in bytes instead of bits. */</span></div><div class="line">        device_size_bytes = (memory_density / 8) + 1;</div><div class="line">    }</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(device_size_bytes);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structspibsc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i_b_s_c.html#structspibsc__instance__ctrl__t">spibsc_instance_ctrl_t</a></td></tr>
<tr class="separator:structspibsc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structspibsc__instance__ctrl__t" id="structspibsc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structspibsc__instance__ctrl__t">&#9670;&nbsp;</a></span>spibsc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spibsc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a6b8a1ae0eed7bca555c94959c1314ae3">spi_flash_api_t::open</a> is called </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6d1d2b0dbbc81e342e67e8e4672522bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d1d2b0dbbc81e342e67e8e4672522bd">&#9670;&nbsp;</a></span>R_SPIBSC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the SPIBSC driver module.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a6b8a1ae0eed7bca555c94959c1314ae3">spi_flash_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_api_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>One or more parameters in p_cfg are not supported by this implementation. </td></tr>
    <tr><td class="paramname">FSP_ERR_OUT_OF_MEMORY</td><td>Memory allocation error. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_SIZE</td><td>Page size is not specified. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_POINTER</td><td>Pointer points to invalid memory location. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with the same p_api_ctrl. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba7eafa9bef7950f16a37accbf6435d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7eafa9bef7950f16a37accbf6435d0">&#9670;&nbsp;</a></span>R_SPIBSC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the SPIBSC driver module.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a16810f14e3fff6ed04f36eca44353785">spi_flash_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5409bfead7139998373b00a9e7ee17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5409bfead7139998373b00a9e7ee17f">&#9670;&nbsp;</a></span>R_SPIBSC_DirectWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_DirectWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>read_after_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED: Writes raw data directly to the flash device.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a31a1d575f3d8876154d4e217caebf110">spi_flash_api_t::directWrite</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After sending operations that change its contents, it may be inconsistent with cached contents. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Its behavior is not guaranteed if the caller and/or the callee are stored in the same device you are trying to change its contents.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Read-after-write is not supported by this implementation. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77245dfca1f1d3e0b8f84d125b34fce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77245dfca1f1d3e0b8f84d125b34fce0">&#9670;&nbsp;</a></span>R_SPIBSC_DirectRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_DirectRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads raw data directly from the flash device. Unsupported by SPIBSC.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a3366fdcb333cb6950ff38bb35618c401">spi_flash_api_t::directRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by SPIBSC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9af815043c15dc43d8964179a5d0cc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9af815043c15dc43d8964179a5d0cc1a">&#9670;&nbsp;</a></span>R_SPIBSC_SpiProtocolSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_SpiProtocolSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga17c347a498a8a9d38ffc36c0de49a535">spi_flash_protocol_t</a>&#160;</td>
          <td class="paramname"><em>spi_protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the SPI protocol.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a3328711e7e70c8379f4373d2861d785a">spi_flash_api_t::spiProtocolSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by SPIBSC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga75bb83a911e944d297109a1293fb8c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75bb83a911e944d297109a1293fb8c18">&#9670;&nbsp;</a></span>R_SPIBSC_XipEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_XipEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ab5c6cc5c82e73038ddcef82a906b966f">spi_flash_api_t::xipEnter</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when already enabled or not 4-bit transfer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08dd33276f59e3978393acf89e2ff889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08dd33276f59e3978393acf89e2ff889">&#9670;&nbsp;</a></span>R_SPIBSC_XipExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_XipExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits XIP (execute in place) mode.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a3a7c2aae058a733f879ae294c63ce2c6">spi_flash_api_t::xipExit</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc110157d679b89cb4c4f752cb4efb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc110157d679b89cb4c4f752cb4efb41">&#9670;&nbsp;</a></span>R_SPIBSC_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program a page of data to the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a61e667a9ae9af76c5f8fd9f1973c6838">spi_flash_api_t::write</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After writing, it may be inconsistent with cached contents. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Its behavior is not guaranteed if the caller and/or the callee are stored in the same device you are writing.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl, p_dest or p_src is NULL, or byte_count crosses a page boundary. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0912fbc1a4e3df240fcaba680d9d71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0912fbc1a4e3df240fcaba680d9d71f">&#9670;&nbsp;</a></span>R_SPIBSC_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase a block or sector of flash. The byte_count must exactly match one of the erase sizes defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>. For chip erase, byte_count must be SPI_FLASH_ERASE_SIZE_CHIP_ERASE.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a0f241a48dd8f386e19a6e0fe44e8a2d9">spi_flash_api_t::erase</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After erasing, it may be inconsistent with cached contents. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Its behavior is not guaranteed if the caller and/or the callee are stored in the same device you are erasing.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The command to erase the flash was executed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl or p_device_address is NULL, or byte_count doesn't match an erase size defined in <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__cfg__t">spi_flash_cfg_t</a>, or device is in XIP mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e1eba14ce00a4c9f7bdc9d5ca473c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e1eba14ce00a4c9f7bdc9d5ca473c5a">&#9670;&nbsp;</a></span>R_SPIBSC_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__status__t">spi_flash_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the write or erase status of the flash.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a1eea2761178ddd8ca7ef3aacd5c80507">spi_flash_api_t::statusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The write status is in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl or p_status is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac19f99e12b8fdb78e2f2895b6f3a9a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19f99e12b8fdb78e2f2895b6f3a9a80">&#9670;&nbsp;</a></span>R_SPIBSC_BankSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_BankSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the bank to access. A bank is a 256Mega-byte access window into the SPI Multi area. To access device address 0x10000000, select bank 1, then read from address 0x20000000(physical). To access device address 0x20001000, select bank 2, then read from address 0x20001000(physical).</p>
<p>This function is not required for memory devices less than or equal to 256Mega-byte.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a14581133205383b71df54a65439c0dcf">spi_flash_api_t::bankSet</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After different bank selections, it becomes inconsistent with cache. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Its behavior is not guaranteed if the caller and/or the callee are stored in the same device you are trying to select banks. After changing the bank, the contents (code, data, or more) of the previously selected bank will become inaccessible.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Bank successfully selected. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>"bank" is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95407b1410c47feb1254068abcee82b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95407b1410c47feb1254068abcee82b0">&#9670;&nbsp;</a></span>R_SPIBSC_DirectTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_DirectTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#structspi__flash__direct__transfer__t">spi_flash_direct_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga80ecf65e658f5b36bfe0bf2d88dd3ca5">spi_flash_direct_transfer_dir_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read/Write raw data directly with the flash device.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#a21da248768dd75281ea7b29f2d243afd">spi_flash_api_t::directTransfer</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After sending operations that change its contents, it may be inconsistent with cached contents. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Its behavior is not guaranteed if the caller and/or the callee are stored in the same device you are trying to change its contents.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when XIP mode is enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f156e54ed8c5bb8f2f2094570fa18cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f156e54ed8c5bb8f2f2094570fa18cc">&#9670;&nbsp;</a></span>R_SPIBSC_AutoCalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_SPIBSC_AutoCalibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ga0f14c8b55d2948c30b99ab157e16488f">spi_flash_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-calibrate the OctaRAM device using the preamble pattern. Unsupported by SPIBSC.</p>
<p>Implements <a class="el" href="group___s_p_i___f_l_a_s_h___a_p_i.html#ad04434e2c049da61d3389355d5961f31">spi_flash_api_t::autoCalibrate</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by SPIBSC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.2.0 User's Manual Copyright  (2022) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
